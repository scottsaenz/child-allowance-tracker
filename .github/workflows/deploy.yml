name: Deploy to AWS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    name: Run Tests and Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        with:
          enable-cache: true

      - name: Install dependencies
        run: |
          uv sync --dev

      - name: Verify and install ruff if needed
        run: |
          echo "=== CHECKING RUFF INSTALLATION ==="
          uv run python --version
          uv run pip list | grep ruff || echo "Ruff not found in pip list"

          # Try to run ruff
          if ! uv run ruff --version > /dev/null 2>&1; then
            echo "Ruff not found, installing explicitly..."
            uv add --dev ruff
          else
            echo "✅ Ruff is available"
            uv run ruff --version
          fi

      - name: Run tests
        run: uv run pytest tests/ -v

      - name: Run linting
        run: |
          uv run ruff check --fix .
          uv run ruff format .

  build:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: test  # Only run if tests pass
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install uv
        uses: astral-sh/setup-uv@v3

      - name: Create Lambda-compatible deployment package using Docker
        run: |
          echo "=== CREATING LAMBDA-COMPATIBLE DEPLOYMENT PACKAGE ==="

          # Create a Dockerfile for building the package
          cat > Dockerfile.lambda << 'EOF'
          FROM public.ecr.aws/lambda/python:3.12

          # Copy requirements
          COPY requirements.txt .

          # Install dependencies in the Lambda environment
          RUN pip install --no-cache-dir -r requirements.txt -t /var/task/

          # List what was installed for debugging (using ls instead of find)
          RUN ls -la /var/task/ | grep pydantic || echo "No pydantic directories found"
          RUN ls -la /var/task/ | grep fastapi || echo "No fastapi directories found"
          RUN ls -la /var/task/pydantic_core/ || echo "pydantic_core directory not found"
          RUN ls -la /var/task/pydantic_core/ | head -5 || echo "pydantic_core contents not accessible"

          # Check for the critical _pydantic_core binary
          RUN ls -la /var/task/pydantic_core/*pydantic_core* || echo "pydantic_core binary not found"

          # Create deployment directory
          RUN mkdir -p /deployment
          RUN cp -r /var/task/* /deployment/

          # Set working directory
          WORKDIR /deployment
          EOF

          # Export dependencies and clean up local project references
          uv export --format requirements-txt --no-hashes --no-dev > requirements.txt

          echo "=== ORIGINAL REQUIREMENTS.TXT ==="
          cat requirements.txt

          # Remove local project references (lines starting with -e or file://)
          grep -v "^-e" requirements.txt | grep -v "^file://" > requirements_clean.txt
          mv requirements_clean.txt requirements.txt

          echo "=== CLEANED REQUIREMENTS.TXT ==="
          cat requirements.txt

          echo "=== BUILDING LAMBDA PACKAGE IN DOCKER ==="

          # Build the Docker image
          docker build -f Dockerfile.lambda -t lambda-builder .

          # Create deployment directory
          mkdir -p deployment

          # Extract the built packages from Docker using docker cp
          echo "=== EXTRACTING PACKAGES FROM DOCKER ==="

          # Create a container without running it
          CONTAINER_ID=$(docker create lambda-builder)

          # Copy files from container to host
          docker cp $CONTAINER_ID:/deployment/. deployment/

          # Clean up container
          docker rm $CONTAINER_ID

          echo "=== VERIFYING EXTRACTED PACKAGES ==="
          ls -la deployment/ | grep pydantic || echo "No pydantic directories found"
          ls -la deployment/pydantic_core/ || echo "pydantic_core directory not found"
          ls -la deployment/pydantic_core/ | head -10 || echo "pydantic_core contents not accessible"

          # Check for the critical binary file
          ls -la deployment/pydantic_core/*pydantic_core* || echo "pydantic_core binary not found"

          # Copy source code
          cp -r src/* deployment/
          cp lambda_function.py deployment/

          # Create deployment zip
          cd deployment && zip -r ../deployment.zip . -x "*.pyc" "*/__pycache__/*" "*.pytest_cache*"

          echo "=== DEPLOYMENT ZIP INFO ==="
          ls -lh ../deployment.zip
          unzip -l ../deployment.zip | grep -E "(pydantic|fastapi|mangum)" | head -10

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-deployment
          path: deployment.zip
          retention-days: 1

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: test  # Can run in parallel with build
    if: github.ref == 'refs/heads/main'  # Only deploy on main branch
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy infrastructure with CDK
        run: |
          # ... your CDK deployment steps ...

  deploy-lambda:
    name: Deploy Lambda Function
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure]  # Wait for both to complete
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Download deployment artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-deployment

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name child-allowance-tracker \
            --zip-file fileb://deployment.zip

  test-deployment:
    name: Test Deployed Application
    runs-on: ubuntu-latest
    needs: deploy-lambda
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Wait for deployment to be ready
        run: sleep 30

      - name: Test deployed Lambda function
        run: |
          echo "=== API GATEWAY DEBUGGING ==="

          # Get API Gateway ID with better error handling
          API_ID=$(aws apigatewayv2 get-apis --query 'Items[?Name==`child-allowance-tracker-api`].ApiId' --output text 2>/dev/null || echo "")

          if [ -z "$API_ID" ] || [ "$API_ID" = "None" ]; then
            echo "❌ API Gateway not found, trying alternative methods..."

            # Try listing all APIs to see what's available
            echo "=== ALL AVAILABLE APIs ==="
            aws apigatewayv2 get-apis --query 'Items[].{Name:Name,ApiId:ApiId,Protocol:ProtocolType}' --output table || echo "Failed to list APIs"

            # Try REST API instead of HTTP API
            echo "=== CHECKING REST APIs ==="
            aws apigateway get-rest-apis --query 'items[?name==`child-allowance-tracker-api`].id' --output text || echo "No REST APIs found"

            # Exit early if no API found
            echo "❌ Cannot proceed without API Gateway ID"
            exit 1
          fi

          echo "API Endpoint: https://${API_ID}.execute-api.us-east-1.amazonaws.com"
          echo "Expected API Gateway ID: xt7m8ql2y6"
          echo "Current API ID: $API_ID"

          # Only proceed if we have a valid API ID
          if [ ! -z "$API_ID" ] && [ "$API_ID" != "None" ]; then
            echo "=== API GATEWAY CONFIGURATION ==="
            aws apigatewayv2 get-api --api-id $API_ID --output table || echo "Failed to get API details"

            echo "=== API GATEWAY ROUTES ==="
            aws apigatewayv2 get-routes --api-id $API_ID --output table || echo "Failed to get routes"

            echo "=== TESTING ENDPOINTS WITH VERBOSE OUTPUT ==="

            # Test endpoints
            API_ENDPOINT="https://${API_ID}.execute-api.us-east-1.amazonaws.com"

            echo "1. Testing health endpoint:"
            curl -v -X GET "${API_ENDPOINT}/health" \
              -H "Accept: application/json" \
              -H "User-Agent: GitHub-Actions-Test" \
              --max-time 30 \
              --connect-timeout 10 || echo "Health endpoint failed"

            echo ""
            echo "2. Testing root endpoint:"
            curl -v -X GET "${API_ENDPOINT}/" \
              -H "Accept: application/json" \
              --max-time 30 \
              --connect-timeout 10 || echo "Root endpoint failed"

            echo ""
            echo "3. Testing debug endpoint:"
            curl -v -X GET "${API_ENDPOINT}/debug" \
              -H "Accept: application/json" \
              --max-time 30 \
              --connect-timeout 10 || echo "Debug endpoint failed"
          else
            echo "❌ Invalid API ID, cannot test endpoints"
          fi

      - name: Check CloudWatch logs
        run: |
          echo "=== WAITING FOR LOGS TO PROPAGATE ==="
          sleep 30

          echo "=== ALL LAMBDA LOGS FROM LAST 5 MINUTES ==="
          aws logs filter-log-events \
            --log-group-name "/aws/lambda/child-allowance-tracker" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --query 'events[*].message' \
            --output text | tail -100 || echo "No logs found"

          echo ""
          echo "=== LAMBDA DEBUG LOGS ==="
          aws logs filter-log-events \
            --log-group-name "/aws/lambda/child-allowance-tracker" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --filter-pattern "DEBUG" \
            --query 'events[*].message' \
            --output text || echo "No debug logs found"

          echo ""
          echo "=== LAMBDA ERROR LOGS ==="
          aws logs filter-log-events \
            --log-group-name "/aws/lambda/child-allowance-tracker" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --filter-pattern "ERROR" \
            --query 'events[*].message' \
            --output text || echo "No error logs found"

          echo ""
          echo "=== LAMBDA EXCEPTION/TRACEBACK LOGS ==="
          aws logs filter-log-events \
            --log-group-name "/aws/lambda/child-allowance-tracker" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --filter-pattern "?Exception ?Traceback ?ImportError" \
            --query 'events[*].message' \
            --output text || echo "No exception logs found"

          echo ""
          echo "=== INIT LOGS (COLD START) ==="
          aws logs filter-log-events \
            --log-group-name "/aws/lambda/child-allowance-tracker" \
            --start-time $(date -d '5 minutes ago' +%s)000 \
            --filter-pattern "?starting ?imported ?created" \
            --query 'events[*].message' \
            --output text || echo "No init logs found"

      - name: Enhanced deployment package verification
        run: |
          echo "=== ENHANCED PACKAGE VERIFICATION ==="

          # Check if we're using the right Python version in deployment
          echo "Python version used for deployment:"
          python3 --version

          echo ""
          echo "=== CHECKING DEPLOYMENT STRUCTURE ==="
          unzip -l deployment.zip | grep -E "\.py$" | head -20

          echo ""
          echo "=== TESTING DEPLOYMENT PACKAGE LOCALLY ==="
          mkdir -p local_test
          cd local_test
          unzip -q ../deployment.zip

          # Set PYTHONPATH to current directory
          export PYTHONPATH=".:$PYTHONPATH"

          echo "Testing imports with PYTHONPATH set to current directory:"
          python3 -c "
          import sys
          import os
          print(f'Python version: {sys.version}')
          print(f'Working directory: {os.getcwd()}')
          print(f'Python path: {sys.path[:5]}')
          print('Files in current directory:')
          for f in os.listdir('.'):
              if f.endswith('.py'):
                  print(f'  {f}')
          " || echo "Basic test failed"

          python3 -c "
          try:
              import lambda_function
              print('✅ lambda_function imported')

              # Check if handler exists and is callable
              if hasattr(lambda_function, 'lambda_handler'):
                  handler = lambda_function.lambda_handler
                  print(f'✅ lambda_handler exists and is callable: {callable(handler)}')
              else:
                  print('❌ lambda_handler not found')

          except Exception as e:
              print(f'❌ lambda_function import failed: {e}')
              import traceback
              traceback.print_exc()
          " || echo "Lambda function test failed"

          python3 -c "
          try:
              import app
              print('✅ app module imported')

              if hasattr(app, 'app'):
                  fastapi_app = app.app
                  print(f'✅ FastAPI app found: {type(fastapi_app)}')
              else:
                  print('❌ FastAPI app not found in app module')

          except Exception as e:
              print(f'❌ app import failed: {e}')
              import traceback
              traceback.print_exc()
          " || echo "App test failed"

      - name: Test FastAPI endpoints
        run: |
          echo "Waiting for API Gateway and Lambda to be ready..."
          sleep 15

          echo "Testing FastAPI via API Gateway..."
          echo "API Endpoint: $API_ENDPOINT"
          echo "==================================="

          # Test health endpoint
          echo "1. Testing health endpoint:"
          HEALTH_RESPONSE=$(curl -s $API_ENDPOINT/health || echo "curl failed")
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/health || echo "status check failed")
          echo "Health Response: $HEALTH_RESPONSE"
          echo "Health HTTP Status: $HEALTH_STATUS"

          echo ""
          echo "2. Testing root endpoint:"
          ROOT_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/ || echo "status check failed")
          echo "Root HTTP Status: $ROOT_STATUS"

          echo ""
          echo "3. Testing API documentation:"
          DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/docs || echo "status check failed")
          echo "Docs HTTP Status: $DOCS_STATUS"

          # Add debug endpoint if it exists
          echo ""
          echo "4. Testing debug endpoint (if exists):"
          DEBUG_RESPONSE=$(curl -s $API_ENDPOINT/debug || echo "debug endpoint not available")
          DEBUG_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/debug || echo "status check failed")
          echo "Debug Response: $DEBUG_RESPONSE"
          echo "Debug HTTP Status: $DEBUG_STATUS"

          echo ""
          echo "5. Testing dashboard API:"
          DASHBOARD_RESPONSE=$(curl -s $API_ENDPOINT/api/dashboard || echo "curl failed")
          DASHBOARD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/api/dashboard || echo "status check failed")
          echo "Dashboard Response: $DASHBOARD_RESPONSE"
          echo "Dashboard HTTP Status: $DASHBOARD_STATUS"

          echo ""
          echo "6. Testing children API:"
          CHILDREN_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $API_ENDPOINT/api/children || echo "status check failed")
          echo "Children API HTTP Status: $CHILDREN_STATUS"

          echo ""
          echo "=== SUMMARY ==="
          if [ "$HEALTH_STATUS" = "200" ]; then
            echo "✅ Health endpoint working!"
          else
            echo "❌ Health endpoint failed"
          fi

          if [ "$ROOT_STATUS" = "200" ]; then
            echo "✅ Root endpoint working!"
          else
            echo "❌ Root endpoint failed"
          fi

          if [ "$DOCS_STATUS" = "200" ]; then
            echo "✅ API documentation working!"
          else
            echo "❌ API documentation failed"
          fi

      - name: Display final URLs
        run: |
          echo "🚀 Deployment Complete!"
          echo "================================="
          echo "Main Application: $API_ENDPOINT/"
          echo "Health Check: $API_ENDPOINT/health"
          echo "API Documentation: $API_ENDPOINT/docs"
          echo "API Dashboard: $API_ENDPOINT/api/dashboard"
          echo "Children API: $API_ENDPOINT/api/children"
          echo ""
          echo "Main Application: $API_ENDPOINT/" >> $GITHUB_STEP_SUMMARY
          echo "API Documentation: $API_ENDPOINT/docs" >> $GITHUB_STEP_SUMMARY
